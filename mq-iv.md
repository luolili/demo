# rmq
1. rmq有 哪几种广播类型
- fanout : 所有 绑定到 此 exchange 的 queue 都可以接受消息
- direct: 通过 routingKey 和 exchange 决定 唯一的 queue 可以接受消息
- topic: 所有符合 routingKey的 都可以接受消息

2.rmq 如何保证消息的稳定性？
> 消费者 在消费完消息之后， 会发送一个回执 给mq, mq收到回执后才把消息从 queue 里面移除，
如果mq 没有收到回执，并发现 消费者 的mq 链接断开了，mq会把消息发给其他消费者。

3.rmq 持久化的缺点？
- 如果 消息是自动确认的话，那么在消息被接受之后，mq就会删除这个消息，如果 消费端此时宕机，
那么消息就丢失了，需要把消息 设置为 手动确认
- 手动确认：在消息确认 过程中 出现问题，在消费端重启之后，消息会被重新消费
- 消息发送到mq之后，在mq 回复 已成功接收消息 的过程中 出现异常，那么发送端会多次发送该消息
- 消息 写入 磁盘 也会出问题

4.rmq 怎么实现延迟消息队列？
- 给消息设置过期时间：ttl

5.rmq是怎么发送消息的？
- rmq相当于 一个邮箱，是一个消息的队列；
- 生产者：发送消息的 人
- Connection:通过 TCP 连接到 rmq server
- channel:发送，接受消息：他可以指定要发送/发送消息的queue

6.rmq 的每个节点都是 其他节点的完整拷贝吗？
- 不是，队列的完整信息，只放在一个节点里面，其他节点放该队列的地址

---
#activemq
1.amq :工作模式？
- 点对点模式：一个消息 只有一个消费者 消费
- 发布/订阅：消费者 只有消费 他 订阅的主题  
##取消订单用 mq

## mq处理减少库存失败怎么办

## 为什么需要 mq（mq 技术选型）
解耦：A 系统生产的数据，放入 公共的地方 让需要这个数据的系统自己取。A系统和其他系统不会耦合在一起，  
使用场景：A系统需要同步调用其它系统的接口/方法，维护成本较高  
异步：提高系统响应速度（200毫秒内），提高接口的性能，A发送消息 到三个消息队列，其他系统分别监听三个消息队列  
削峰：100万用户请求过来，A 系统每秒处理5000个请求，mysql 每秒2000条sql，mysql打死了；100万请求，每秒5000个请求进入 mq，系统A每秒拉去2000个请求，A不会挂掉有些请求是挤压到 mq，每秒挤压3000个请求，高峰期1小时：3000*60*60个请求被挤压。一个小时候被积压的消息会被完全消费
##mq的缺点
可用性降低：mq不能用了，所有系统不能用了。  
系统复杂度变高：消息重复发送，其他系统插入了2次数据到数据库；消息丢了；，消息的顺序乱了，导致数据乱了；消息大量被挤压。  
一致性：接受消息的系统里面某些系统执行失败了
##rmq,amq,kafka 的区别
吞吐量：amq:万级别请求；低丢消息；官方维护少；功能完备；适合小规模项目  
吞吐量：rmq:万级别请求；性能高（erlang语言开发）；低丢消息；延时低；维护多；功能完备；有管理界面；  
吞吐量：romq:十万级别请求；性能高，分布式扩展方便；低丢消息；延时低；维护多；功能完备；    
吞吐量：kafka:十万级别请求；低丢消息；延时低；维护多；功能简单，易扩展；大数据领域；    
##mq 的高可用怎么做
rmq:  
普通集群：每台机器有一个 rmq 的实例，只有一个节点上有实际的数据，其他节点只有元数据（实际数据的地址）--不算高可用：数据传输太多； 
镜像集群：所有节点 都有实际的数据copy，从任何节点访问都可以，不怕某些节点宕机，-- 不是分布式：一个数据大到一个机器容纳不了。
##防止重复的消费（幂等性）
对于数据库，先查是否有这条数据了，有就更新；  
设置表的唯一键  
对于内存 set，有就不 add  
对于redis,直接 set，redis 的 set 是幂等性的
##消息丢了（可靠性）
生产者弄丢了：在生产者开启事务，捕获异常，失败重试 。他是同步，很卡，吞吐量低；confirm 机制，把 channel 设为 confirm 模式，mq 接受到消息后会给生产者发送接收成功的消息，失败重试。生产者提供成功和失败的 callback 方法 
mq 弄丢了：把收到的消息持久化到磁盘，queue 设为持久化+deviveryMode=2  
消费者弄丢了：autoack 机制，消费者接收到消息自动发消息是成功消费了，但消息还未处理，要关闭 autoack，自己消费处理完了才发送 ack 消息，即使自己宕机没处理完，mq会把消息发给其他消费方处理 
##消息的顺序乱了
rmq:  
把多个需要有顺序的消息都发送到同一个 queue 里面，从而他们只被一个消费者消费掉，保存到数据库就是顺序的
##百万条消息被积压（消息队列满了/消费者挂了/磁盘满了）怎么办
新建一个 topic 一个 topic 有30个 partition（更多的 partition） , 部署30个消费者（更多的 消费者）  
磁盘满了：消费了，就扔掉数据，后面再补上
## mq 如何设计
1.可扩容：分布式 mq ，参照 kafka,broker 节点 对应多个 topic，一个 topic 对应多个 partition  
2.可持久化  
3.高可用：redis leader-follower  
4.消息丢了



