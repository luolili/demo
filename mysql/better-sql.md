##1.explain 各个参数的含义

1.rows: 扫描的行数
2.type:链接类型，好的sql至少是range级别。

3.key_len:索引长度
4.key：用到的索引的名字

## 2.in 包含的值不能太多
in 里面的常量会被存入一个数组，而且这个数组是排好序的，对于连续的数，用between，或join

##3.当只需要一条数据的时候，用limit 1
他可让type列是const类型

##4.区分in 和 exists

select * from A where id in (select id from B)

select * from A where exists(select * from B  where B.id = A.id)
in 是先执行子查询，适合外表大内表小；
exists 先执行父查询
##5.不在 where 后面进行 null判断和计算

##6.避免隐士类型转换

##库和表的字符集用uft-8
兼容性更好
##单表的数据小于500万
历史数据归档（日志数据），分库分表
##冷热数据分离，减小表的宽度
避免更多的关联操作
##优先用更小的数据存储类型
列的字段越大，建立索引所需空间更大；ip地址转为整形:inet_aton；  
自增id用无符号整形；varchar(255)可以存255个汉字，占765字节
##避免用text,blob
text 占64k数据，mysql的临时表不支持 text，blob大数据类型
##不要用 UUID MD5 HASH 字符串作为主键
无法保证数据的顺序增长
##把区分度最高，字段长度小，使用最频繁的放在联合索引最左
提高 io性能，减少索引的建立
##避免用外键约束
在业务端实现数据的参照完整性，外键会影响父表和子表的写操作
##不同的数据库用不同的账号，禁止跨库查询
安全性
##避免子查询，用 join
子查询的结果集无法用到索引

子查询一般出现在 in 子句里面，子查询是简单sql（没有 union,group by,order by limit），才可变为 join
##避免关联太多的表，小于5张表
##对同一类可以用 or 的时候，用 in来代替
in 的值不超过500个，性能更好
##大 sql 分成 小 sql
一个 sql 只用 一个 cpu
##超过100玩行的批量操作，要分批次进行
造成扈从延迟；大批量修改，一定是在一个事务里进行的，从而导致大量的阻塞，
让其他应用无法链接到数据库